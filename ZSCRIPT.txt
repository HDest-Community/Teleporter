version "4.0"

class HDTeleporterHandler : EventHandler
{
	override void CheckReplacement(ReplaceEvent e)
	{
		if (!e.Replacement)
		{
			return;
		}
	}

	override void WorldThingSpawned(WorldEvent e)
	{
		let TeleporterAmmo = HDBattery(e.Thing);
		if (TeleporterAmmo)
		{
			TeleporterAmmo.ItemsThatUseThis.Push("HDTeleporter");
		}
	}
}

class HDTeleporter : HDWeaponGrabber
{
	enum TeleporterFlags
	{
		TF_JustUnload = 1
	}
	enum TeleporterProperties
	{
		TProp_Flags,
		TProp_Battery
	}

	override void DoEffect()
	{
		Cooldown--;
		if (TimesFumbled > 0 && Cooldown <= 0)
		{
			TimesFumbled--;
			Cooldown = 9;
		}

		Super.DoEffect();
	}

	override bool Use(bool pickup)
	{
		let plr = HDPlayerPawn(owner);
		if (!plr || plr.incapacitated <= 0)
		{
			return Super.Use(pickup);
		}

		plr.A_StartSound("weapons/pocket", 20);
		if (++TimesFumbled >= 7)
		{
			if (Rift && WeaponStatus[TProp_Battery] >= ActivationCost)
			{
				A_TeleportToRift(Rift, true);
			}
			else if (!Rift && WeaponStatus[TProp_Battery] >= ActivationCost * 2)
			{
				A_OpenRift(42 * 20, true);
				A_TeleportToRift(Rift, false);
			}
			TimesFumbled = 0;
		}

		return Super.Use(pickup);
	}

	override string GetHelpText()
	{
		return WEPHELP_FIRE.."  Open rift and teleport\n"
		..WEPHELP_ALTFIRE.."  Open rift/teleport to rift\n"
		..WEPHELP_RELOADRELOAD
		..WEPHELP_UNLOADUNLOAD
		..WEPHELP_FIREMODE.."  Grab/drag";
	}

	override void DropOneAmmo(int amt)
	{
		if (owner)
		{
			amt = clamp(amt, 1, 10);
			owner.A_DropInventory("HDBattery", 1);
		}
	}

	override bool AddSpareWeapon(actor newowner) { return AddSpareWeaponRegular(newowner); }
	override HDWeapon GetSpareWeapon(actor newowner, bool reverse, bool doselect) {return GetSpareWeaponRegular(newowner, reverse, doselect); }
	override double GunMass() { return 0; }
	override double WeaponBulk() { return 10; }
	override string, double GetPickupSprite() { return "TPRTZ0", 1.0; }
	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		if (sb.HudLevel == 1)
		{
			sb.DrawBattery(-54, -4, sb.DI_SCREEN_CENTER_BOTTOM, reloadorder: true);
			sb.DrawNum(hpl.CountInv("HDBattery"), -46, -8, sb.DI_SCREEN_CENTER_BOTTOM);
		}

		int BatteryCharge = hdw.WeaponStatus[TProp_Battery];
		if (BatteryCharge > 0)
		{
			sb.DrawWepNum(BatteryCharge, 20);
		}
		else if (BatteryCharge == 0)
		{
			sb.DrawString(sb.mAmountFont, "00000", (-16, -10), sb.DI_TEXT_ALIGN_RIGHT | sb.DI_TRANSLATABLE | sb.DI_SCREEN_CENTER_BOTTOM, Font.CR_DARKGRAY);
		}
	}
	override void InitializeWepStats(bool idfa)
	{
		WeaponStatus[TProp_Battery] = 20;
	}

	private action void A_TeleportToRift(HDTeleporterRift rf, bool destroyRift)
	{
		A_WeaponOffset(1, 3, WOF_ADD); // [Ace] Should this even be here?
		if (!rf)
		{
			return;
		}

		let plr = HDPlayerPawn(invoker.owner);
		Actor OldTracer = plr.tracer; // [Ace] Just in case.
		
		double ThrustAngle = plr.AngleTo(rf);
		if (plr.Warp(rf, 0, 0, -(plr.height / 2), flags: WARPF_USECALLERANGLE | WARPF_NOCHECKPOSITION))
		{
			plr.A_ChangeVelocity(8 * cos(ThrustAngle), 8 * sin(ThrustAngle), 0);
			for (int i = 0; i < 360; ++i)
			{
				if (!random(0, 1))
				{
					plr.A_SpawnParticle(0x392249, SPF_RELATIVE, random(20, 50), random(4, 6), i, random(8, 16), 0, frandom(0, height), random(4, 16), 0, frandom(-3, 3), 0, 0, frandom(-0.05, 0));
				}
				plr.A_SpawnParticle(0x392249, SPF_RELATIVE, 15, 16, i, 0, 0, 0, 20, 0, 0, -0.8, sizestep: 0.6);
			}

			// [Ace] Take whatever you're holding with you. Provided you have enough space.
			if (invoker.Grabbed)
			{
				invoker.Grabbed.Warp(rf, plr.radius + invoker.Grabbed.Radius + 8, angle: plr.angle, flags: WARPF_ABSOLUTEANGLE);
				invoker.Grabbed.A_ChangeVelocity(3, 0, 0, CVF_RELATIVE);
				A_ClearGrabbing();
			}

			invoker.WeaponStatus[TProp_Battery] -= ActivationCost;
			plr.burncount += 5;
			if (destroyRift)
			{
				rf.Destroy();
			}
			plr.A_PlaySound("HDTeleporter/Teleport", 11);
			plr.tracer = OldTracer;
		}
		else
		{
			plr.A_Log("Destination is blocked. Force-closing rift.", true);
			rf.Destroy();
			plr.tracer = OldTracer;
		}
	}

	private action void A_OpenRift(int dist, bool instant)
	{
		let plr = HDPlayerPawn(invoker.owner);
		FLineTraceData Data;
		for (int i = dist; i >= 16; i -= 16)
		{
			plr.LineTrace(plr.angle, i, plr.pitch, TRF_NOSKY | TRF_THRUACTORS | TRF_THRUBLOCK | TRF_THRUHITSCAN, height - 4, 0, 0, Data);
			if (Data.HitType == Data.TRACE_HitNone)
			{
				plr.LineTrace(plr.angle, i - 16, plr.pitch, TRF_NOSKY | TRF_THRUACTORS | TRF_THRUBLOCK | TRF_THRUHITSCAN, height - 4, 0, 0, Data);
				break;
			}
		}
		invoker.Rift = HDTeleporterRift(Spawn("HDTeleporterRift", Data.HitLocation));
		if (instant)
		{
			invoker.Rift.Instant = instant;
		}
		invoker.WeaponStatus[TProp_Battery] -= ActivationCost;
	}

	const ActivationCost = 2;
	private int Cooldown;
	private int TimesFumbled;
	private HDTeleporterRift Rift;

	Default
	{
		Scale 0.5;
		+WEAPON.WIMPY_WEAPON
		+INVENTORY.INVBAR
		+HDWEAPON.FITSINBACKPACK
		HDWeapon.RefID "ptp";
		Inventory.Icon "TPRTZ0";
		Inventory.PickupMessage "Picked up a portable teleporter.";
		Tag "Portable teleporter";
	}

	States
	{
		Spawn:
			TPRT Z -1;
			Stop;
		Select0:
			TPRT AAA 1 A_Raise(24);
			TPRT A 1
			{
				A_Raise(8);
				A_StartSound("HDTeleporter/Safety", 10, volume: 0.5);
			}
			TPRT BBCC 1 A_Raise(8);
			Wait;
		Deselect0:
			TPRT C 1 A_Lower(32);
			Wait;
		Ready:
			TPRT C 1 A_WeaponReady(WRF_ALL);
			Goto ReadyEnd;
		Firemode:
			TPRT C 0 A_ClearGrabbing();
		GrabHold:
			TPRT C 1 A_CheckGrabbing();
			TPRT C 0 A_JumpIf(PressingFire(), "Fire");
			TPRT C 0 A_JumpIf(PressingAltfire(), "AltFire");
			TPRT C 0 A_JumpIf(PressingFiremode(), "GrabHold");
			TPRT C 0 A_ClearGrabbing();
			Goto Nope;
		Fire:
			TPRT C 1
			{
				invoker.bWEAPONBUSY = true;
				A_StartSound("HDTeleporter/Button", 10, volume: 0.5);
				A_WeaponOffset(1, 12, WOF_ADD);
			}
			TPRT D 1 A_WeaponOffset(1, 6, WOF_ADD);
			TPRT E 8
			{
				if (invoker.WeaponStatus[TProp_Battery] >= ActivationCost * 2)
				{
					HDTeleporterRift OldRift = invoker.Rift;
					A_OpenRift(42 * 20, true);
					A_TeleportToRift(invoker.Rift, false);
					invoker.Rift = OldRift;
				}
			}
			TPRT EDC 1 A_WeaponOffset(-1, -7, WOF_ADD);
			TPRT C 0 { invoker.bWEAPONBUSY = false; }
			Goto Nope;
		AltFire:
			TPRT C 1
			{
				invoker.bWEAPONBUSY = true;
				A_StartSound("HDTeleporter/Button", 10, volume: 0.5);
				A_WeaponOffset(1, 12, WOF_ADD);
			}
			TPRT D 1 A_WeaponOffset(1, 6, WOF_ADD);
			TPRT E 8
			{
				if (invoker.WeaponStatus[TProp_Battery] >= ActivationCost)
				{
					if (invoker.Rift)
					{
						A_TeleportToRift(invoker.Rift, true);
					}
					else
					{
						A_OpenRift(42 * 2, false);
					}
				}
			}
			TPRT EDC 1 A_WeaponOffset(-1, -7, WOF_ADD);
			TPRT C 0 { invoker.bWEAPONBUSY = false; }
			Goto Nope;

		Reload:
			TPRT C 0
			{
				invoker.WeaponStatus[TProp_Flags] &= ~TF_JustUnload;
				bool NoMags = HDMagAmmo.NothingLoaded(self, "HDBattery");
				if (invoker.WeaponStatus[TProp_Battery] >= 20 || NoMags)
				{
					SetWeaponState("Nope");
				}
			}
			Goto RemoveBattery;
		Unload:
			TPRT C 0
			{
				invoker.WeaponStatus[TProp_Flags] |= TF_JustUnload;
				if (invoker.WeaponStatus[TProp_Battery] == -1)
				{
					SetWeaponState("Nope");
				}
			}
			Goto RemoveBattery;
		RemoveBattery:
			TPRT C 1 Offset(0, 36) A_SetCrosshair(21);
			TPRT C 1 Offset(2, 42);
			TPRT C 2 Offset(4, 50);
			TPRT C 3 Offset(6, 56) A_StartSound("weapons/pismagclick", 8, CHANF_OVERLAP);
			TPRT C 0
			{
				int Bat = invoker.WeaponStatus[TProp_Battery];
				invoker.WeaponStatus[TProp_Battery] = -1;
				if (Bat == -1)
				{
					SetWeaponState("BatteryOut");
				}
				else if((!PressingUnload() && !PressingReload()) || A_JumpIfInventory("HDBattery", 0, "null"))
				{
					HDMagAmmo.SpawnMag(self, "HDBattery", Bat);
					SetWeaponState("BatteryOut");
				}
				else
				{
					HDMagAmmo.GiveMag(self, "HDBattery", Bat);
					A_StartSound("weapons/pocket", 9);
					SetWeaponState("PocketMag");
				}
			}
		PocketMag:
			TPRT CCC 5 Offset(0, 46) A_MuzzleClimb(frandom(-0.1, 0.2), frandom(-0.2, 0.4));
			Goto BatteryOut;
		BatteryOut:
			TPRT C 0
			{
				if (invoker.WeaponStatus[TProp_Flags] & TF_JustUnload)
				{
					SetWeaponState("ReloadEnd");
				}
			}
		LoadMag:
			TPRT C 4 Offset(0, 53) A_MuzzleClimb(frandom(-0.2, 0.4), frandom(-0.2, 0.4));
			TPRT C 0 A_StartSound("weapons/pocket", 9);
			TPRT C 5 Offset(0, 56) A_MuzzleClimb(frandom(-0.2, 0.4), frandom(-0.2, 0.4));
			TPRT C 3;
			TPRT C 0
			{
				let Bat = HDMagAmmo(FindInventory("HDBattery"));
				if (Bat)
				{
					invoker.WeaponStatus[TProp_Battery] = Bat.TakeMag(true);
					A_StartSound("weapons/pismagclick", 8);
				}
			}
			Goto ReloadEnd;
		ReloadEnd:
			TPRT C 2 Offset(6, 50);
			TPRT C 1 Offset(4, 42);
			TPRT C 1 Offset(2, 36);
			TPRT C 1 Offset(1, 32);
			Goto Nope;
		User3:
			TPRT A 0 A_MagManager("HDBattery");
			Goto Ready;
	}
}

class HDTeleporterRift : Actor
{
	Default
	{
		+NOBLOCKMAP
		+NOGRAVITY
		+FIXMAPTHINGPOS
		ReactionTime 35 * 60;
		Radius 16;
		Height 4;
	}

	bool Instant;

	States
	{
		Spawn:
			RFTG A 0 NoDelay
			{
				DistantNoise.Make(self, "world/tbfar");
				DistantNoise.Make(self, "world/tbfar2", 2.0);
				DistantQuaker.Quake(self, 5, 50, 2048, 8, 128, 256, 256);

				for(int i = 0; i < 3; ++i)
				{
					A_SpawnItemEx("WallChunker", frandom(-4 ,4), frandom(-4, 4), -4, flags:SXF_NOCHECKPOSITION | SXF_TRANSFERPOINTERS);
				}
				
				A_StartSound("weapons/plascrack", 11);
				A_StartSound("weapons/plascrack", 12);
				A_StartSound("world/tbfar", 14);
				A_StartSound("world/explode", 15);
				if (Instant)
				{
					Destroy();
				}
			}
		SpawnLoop:
			TNT1 A 1
			{
				for (int i = 0; i < 4; ++i)
				{
					int SpawnPitch = random(-80, 80);
					int SpawnAngle = random(0, 359);
					double sinp = sin(SpawnPitch);
					double cosp = cos(SpawnPitch);
					Color col = randompick(0x0f0b19, 0x171127, 0x201735);
					double AgeFactor = max(0.1, (ReactionTime / double(default.ReactionTime)));
					double SpawnDist = random(128, 192) * AgeFactor;
					int Speed = -4;
					double Acceleration = -0.05;
					A_SpawnParticle(col, SPF_RELATIVE, int(35 * AgeFactor), frandom(5.0, 8.0), SpawnAngle, SpawnDist * cosp, 0, (SpawnDist * sinp) / 1.2, Speed * cosp, 0, (Speed * sinp) / 1.2, Acceleration * cosp, 0, (Acceleration * sinp) / 1.2);
				}

				A_SpawnItemEx("HDRiftSmoke", flags: SXF_SETMASTER);

				if (--ReactionTime <= 0)
				{
					SetStateLabel("Death");
					return;
				}
			}
			Loop;
	}
}

class HDRiftSmoke : Actor
{
	override void PostBeginPlay()
	{
		A_SetRoll(random(0, 359));
		if (master)
		{
			A_SetScale(max(0.05, frandom(0.20, 0.40) * (master.ReactionTime / double(master.default.ReactionTime))));
		}
		else
		{
			A_SetScale(0.05);
		}

		Super.PostBeginPlay();
	}

	Default
	{
		+NOINTERACTION
		+ROLLSPRITE
		+FORCEXYBILLBOARD
		RenderStyle "Shaded";
	}

	States
	{
		Spawn:
			RFSM K 1
			{
				if (!random(0, 2))
				{
					SetShade(0x2c243d);
				}
				else if (!random(0, 2))
				{
					SetShade(0x181127);
				}
				else
				{
					SetShade(0x07060a);
				}
				A_FadeOut(0.12);
				A_SetScale(Scale.X - 0.02);
			}
	}
}