version "4.0"

class HDTeleporterHandler : StaticEventHandler
{
	override void CheckReplacement(ReplaceEvent e)
	{
		if (!e.Replacement)
		{
			return;
		}

		switch (e.Replacement.GetClassName())
		{
			case 'CellPackReplacer':
				if (random[telerand]() <= 16)
				{
					e.Replacement = "RiftGrenadeStack";
				}
				break;
		}
	}

	override void NetworkProcess(ConsoleEvent e)
	{
		let plr = HDPlayerPawn(players[e.Player].mo);
		if (!plr)
		{
			return;
		}

		bool Alive = plr.Health > 0;
		if (Alive && e.Name ~== "HDT_ListRifts")
		{
			static const string Directions[] = { "West", "South-West", "South", "South-East", "East", "North-East", "North", "North-West" };
			int RiftCount = 0;
			string RiftList = "";

			ThinkerIterator it = ThinkerIterator.Create("HDTeleporterRift", Thinker.STAT_DEFAULT);
			Actor a;
			while ((a = Actor(it.Next())))
			{
				vector3 RiftPos = a.pos;
				double Angle = (180 + plr.AngleTo(a) + 22.5) % 360;
				int TotalSeconds = a.ReactionTime / 35 + random(0, 30);
				int MinutesLeft = TotalSeconds / 60;
				int SecondsLeft = TotalSeconds % 60;
				RiftList = String.Format("%sRift at %i, %i, %i. Relative direction: %s. Estimated time until collapse: %i:%02i.\n", RiftList, RiftPos.x, RiftPos.y, RiftPos.z, Directions[int(Angle / 45)], MinutesLeft, SecondsLeft);
				RiftCount++;
			}
			if (RiftCount > 0)
			{
				string FinalString = String.Format("There %s %i open rift%s:\n%s", (RiftCount > 1 ? "are" : "is"), RiftCount, (RiftCount > 1 ? "s" : ""), RiftList);
				plr.A_Log(FinalString, true);
			}
			else
			{
				plr.A_Log("There are no open rifts.", true);
			}
		}
	}
}

class HDTeleporter : HDWeaponGrabber
{
	enum TeleporterProperties
	{
		TProp_Flags,
		TProp_TeleType // [Ace] 0 = Closest, 1 = Farthest.
	}

	override string GetHelpText()
	{
		return WEPHELP_FIRE.."  Teleport to nearest rift\n"
		..WEPHELP_ALTFIRE.."  Teleport to farthest rift";
	}

	override bool AddSpareWeapon(actor newowner) { return AddSpareWeaponRegular(newowner); }
	override HDWeapon GetSpareWeapon(actor newowner, bool reverse, bool doselect) {return GetSpareWeaponRegular(newowner, reverse, doselect); }
	override double GunMass() { return 0; }
	override double WeaponBulk() { return 10; }
	override string, double GetPickupSprite() { return "TPRTZ0", 1.0; }

	Default
	{
		Scale 0.5;
		+WEAPON.WIMPY_WEAPON
		+INVENTORY.INVBAR
		+HDWEAPON.FITSINBACKPACK
		HDWeapon.RefID "ptp";
		Inventory.Icon "TPRTZ0";
		Inventory.PickupMessage "Picked up a portable teleporter.";
		Tag "Portable Teleporter";
	}

	States
	{
		Spawn:
			TPRT Z -1;
			Stop;
		Select0:
			TPRT AAA 1 A_Raise(24);
			TPRT A 1
			{
				A_Raise(8);
				A_StartSound("HDTeleporter/Safety", 10, volume: 0.5);
			}
			TPRT BBCC 1 A_Raise(8);
			Wait;
		Deselect0:
			TPRT C 1 A_Lower(32);
			Wait;
		Ready:
			TPRT C 1 A_WeaponReady(WRF_ALL);
			Goto ReadyEnd;
		Firemode:
			TPRT C 0 A_ClearGrabbing();
		GrabHold:
			TPRT C 1 A_CheckGrabbing();
			TPRT C 0 A_JumpIf(PressingFire(), "Fire");
			TPRT C 0 A_JumpIf(PressingAltfire(), "AltFire");
			TPRT C 0 A_JumpIf(PressingFiremode(), "GrabHold");
			TPRT C 0 A_ClearGrabbing();
			Goto Nope;
		Reload: // [Ace] Disable this. It won't be used.
			Stop;
		Fire:
			TPRT C 0 { invoker.WeaponStatus[TProp_TeleType] = 0; }
			Goto Teleportium;
		AltFire:
			TPRT C 0 { invoker.WeaponStatus[TProp_TeleType] = 1; }
			Goto Teleportium;
		Teleportium:
			TPRT C 1
			{
				invoker.bWEAPONBUSY = true;
				A_StartSound("HDTeleporter/Button", 10, volume: 0.5);
				A_WeaponOffset(1, 12, WOF_ADD);
			}
			TPRT D 1 A_WeaponOffset(1, 6, WOF_ADD);
			TPRT E 8
			{
				A_WeaponOffset(1, 3, WOF_ADD);
				Actor OldTracer = tracer; // [Ace] Just in case.
				CheckProximity("HDTeleporterRift", 65535, 1, (invoker.WeaponStatus[TProp_TeleType] == 0 ? CPXF_CLOSEST : CPXF_FARTHEST) | CPXF_SETTRACER);
				HDTeleporterRift Rift = HDTeleporterRift(tracer);
				if (!Rift || !Rift.Active)
				{
					return;
				}

				if (Warp(Rift, 0, 0, -(height / 2), flags: WARPF_USECALLERANGLE))
				{
					A_ChangeVelocity(2, 0, 0, CVF_RELATIVE);
					for (int i = 0; i < 360; ++i)
					{
						if (!random(0, 1))
						{
							A_SpawnParticle(0x392249, SPF_RELATIVE, random(20, 50), random(4, 6), i, random(8, 16), 0, frandom(0, height), random(4, 16), 0, frandom(-3, 3), 0, 0, frandom(-0.05, 0));
						}
						A_SpawnParticle(0x392249, SPF_RELATIVE, 15, 16, i, 0, 0, 0, 20, 0, 0, -0.8, sizestep: 0.6);
					}

					// [Ace] Take whatever you're holding with you. Provided you have enough space.
					let Teleporter = HDTeleporter(player.ReadyWeapon);
					if (Teleporter && Teleporter.Grabbed)
					{
						Teleporter.Grabbed.Warp(Rift, radius + Teleporter.Grabbed.Radius + 8, angle: angle, flags: WARPF_ABSOLUTEANGLE);
						Teleporter.Grabbed.A_ChangeVelocity(2, 0, 0, CVF_RELATIVE);
						A_ClearGrabbing();
					}

					Rift.ReactionTime -= Rift.default.ReactionTime / 4;
					A_PlaySound("HDTeleporter/Teleport", 11);
				}
				else
				{
					A_Log("Destination is blocked. Force-closing rift.", true);
					Rift.Destroy();
				}

				tracer = OldTracer;
			}
			TPRT EDC 1 A_WeaponOffset(-1, -7, WOF_ADD);
			TPRT C 0 { invoker.bWEAPONBUSY = false; }
			Goto Nope;
	}
}

class HDTeleporterRift : Actor
{
	Default
	{
		ReactionTime 35 * 60 * 30;
		Radius 2;
		Height 4;
	}

	bool Active;

	States
	{
		Spawn:
			RFTG # 0 NoDelay A_JumpIf(pos.z - floorz > 1, 2);
			RFTG # 10 A_ChangeVelocity(0, 0, 8);
			RFTG # 0
			{
				DistantNoise.Make(self, "world/tbfar");
				DistantNoise.Make(self, "world/tbfar2", 2.0);
				DistantQuaker.Quake(self, 5, 50, 2048, 8, 128, 256, 256);

				DistantNoise.Make(self, "world/tbfar");
				for(int i = 0; i < 3; ++i)
				{
					A_SpawnItemEx("WallChunker", frandom(-4 ,4), frandom(-4, 4), -4, flags:SXF_NOCHECKPOSITION | SXF_TRANSFERPOINTERS);
				}
				
				A_StartSound("weapons/plascrack", 11);
				A_StartSound("weapons/plascrack", 12);
				A_StartSound("weapons/plascrack", 13);
				A_StartSound("world/tbfar", 14);
				A_StartSound("world/explode", 15);

				A_Log(String.Format("A rift in space was opened near (%i, %i, %i).", pos.x, pos.y, pos.z));
				bNOINTERACTION = true;
				A_Stop();
				Active = true;
			}
		SpawnLoop:
			TNT1 A 1
			{
				for (int i = 0; i < 4; ++i)
				{
					int SpawnPitch = random(-80, 80);
					int SpawnAngle = random(0, 359);
					double sinp = sin(SpawnPitch);
					double cosp = cos(SpawnPitch);
					Color col = randompick(0x0f0b19, 0x171127, 0x201735);
					double AgeFactor = max(0.1, (ReactionTime / double(default.ReactionTime)));
					double SpawnDist = random(128, 192) * AgeFactor;
					int Speed = -4;
					double Acceleration = -0.05;
					A_SpawnParticle(col, SPF_RELATIVE, int(35 * AgeFactor), frandom(5.0, 8.0), SpawnAngle, SpawnDist * cosp, 0, (SpawnDist * sinp) / 1.2, Speed * cosp, 0, (Speed * sinp) / 1.2, Acceleration * cosp, 0, (Acceleration * sinp) / 1.2);
				}

				A_SpawnItemEx("HDRiftSmoke", flags: SXF_SETMASTER);

				if (--ReactionTime <= 0)
				{
					SetStateLabel("Death");
					return;
				}
			}
			Loop;
	}
}

class HDRiftSmoke : Actor
{
	override void PostBeginPlay()
	{
		A_SetRoll(random(0, 359));
		if (master)
		{
			A_SetScale(max(0.05, frandom(0.20, 0.40) * (master.ReactionTime / double(master.default.ReactionTime))));
		}
		else
		{
			A_SetScale(0.05);
		}

		Super.PostBeginPlay();
	}

	Default
	{
		+NOINTERACTION
		+ROLLSPRITE
		+FORCEXYBILLBOARD
		RenderStyle "Shaded";
	}

	States
	{
		Spawn:
			RFSM K 1
			{
				if (!random(0, 2))
				{
					SetShade(0x2c243d);
				}
				else if (!random(0, 2))
				{
					SetShade(0x181127);
				}
				else
				{
					SetShade(0x07060a);
				}
				A_FadeOut(0.12);
				A_SetScale(Scale.X - 0.02);
			}
	}
}

class HDRiftGrenades : HDGrenadethrower
{
	Default
	{
		Weapon.SelectionOrder 1010;
		Weapon.SlotPriority 0.1;
		Weapon.SlotNumber 0;
		Tag "Rift Grenades";
		HDGrenadeThrower.AmmoType "HDRiftGrenadeAmmo";
		HDGrenadeThrower.ThrowType "HDRiftGrenade";
		HDGrenadeThrower.SpoonType "DoomBuilderCamera";
		Inventory.Icon "RFTGA0";
	}

	override string GetHelpText()
	{
		if (WeaponStatus[0] & FRAGF_SPOONOFF)
		{
			return WEPHELP_FIRE.."  Wind up, release to throw";
		}
		return WEPHELP_FIRE.."  Twist top/wind up (release to throw)\n"
		..WEPHELP_ALTFIRE.."  Twist top, again to arm grenade\n"
		..WEPHELP_RELOAD.."  Abort/untwist top\n";
	}
	
	override string, double GetPickupSprite() { return "RFTGA0", 0.7; }
	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		if (sb.hudlevel == 1)
		{
			sb.DrawImage((WeaponStatus[0] & FRAGF_PINOUT) ? "RFTGF0" : "RFTGA0", (-52, -4), sb.DI_SCREEN_CENTER_BOTTOM, scale:(0.7, 0.7));
			sb.DrawNum(hpl.CountInv("HDRiftGrenadeAmmo"), -45, -8, sb.DI_SCREEN_CENTER_BOTTOM);
		}
		sb.DrawWepNum(hpl.CountInv("HDRiftGrenadeAmmo"), (HDCONST_MAXPOCKETSPACE / ENC_FRAG));
		sb.DrawWepNum(hdw.WeaponStatus[FRAGS_FORCE], 50, posy: -10, alwaysprecise: true);
		
		if(!(hdw.WeaponStatus[0] & FRAGF_SPOONOFF))
		{
			sb.DrawRect(-21, -19, 5, 4);
			if(!(hdw.weaponstatus[0] & FRAGF_PINOUT))
			{
				sb.DrawRect(-25, -18, 3, 2);
			}
		}
		else
		{
			int timer = hdw.WeaponStatus[FRAGS_TIMER];
			if (timer % 3)
			{
				sb.DrawWepNum(140 - timer, 140, posy:  -15, alwaysprecise: true);
			}
		}
	}
	
	override void ForceBasicAmmo()
	{
		owner.A_SetInventory("HDRiftGrenadeAmmo",1);
	}
	
	States
	{
		DeselectInstant:
			TNT1 A -1 A_TakeInventory("HDRiftGrenades", 1);
			Stop;
	}
}

class HDRiftGrenadeRoller : HDFragGrenadeRoller
{
	Default
	{
		Scale 0.5;
		Obituary "%k's rift blew a hole in %o.";
		Mass 50;
		+ROLLSPRITE
		+ROLLCENTER
	}

	States
	{
		Spawn:
			RFTG BCDE 2 NoDelay
			{
				if (abs(vel.z - keeprolling.z) > 10)
				{
					A_StartSound("misc/fragknock", CHAN_BODY);
				}
				else if (floorz >= pos.z)
				{
					A_StartSound("misc/fragroll");
				}
				keeprolling = vel;
				if(abs(vel.x) < 0.4 && abs(vel.y) < 0.4)
				{
					SetStateLabel("Death");
				}
				A_SetRoll(random(-45, 45));
			}
			Loop;
		Bounce:
			RFTG A 0
			{
				bMISSILE = false;
				vel *= 0.3;
			}
			Goto Spawn2;
		Death:
			RFTG # 2
			{
				if(abs(vel.z - keeprolling.z) > 3)
				{
					A_StartSound("misc/fragknock", CHAN_BODY);
					keeprolling = vel;
				}
				if (abs(vel.x) > 0.4 || abs(vel.y) > 0.4)
				{
					SetStateLabel("Spawn");
				}
			}
			Wait;
		Destroy:
			RFTG # 1 A_SpawnItemEx("HDTeleporterRift", flags: SXF_TRANSFERSPRITEFRAME | SXF_TRANSFERSCALE);
			Stop;
	}
}

class HDRiftGrenade : HDFragGrenade
{
	Default
	{
		Scale 0.5;
		Obituary "%k tried to telefrag %o. Unfortunately, that's not how telefragging works.";
		HDFragGrenade.RollerType "HDRiftGrenadeRoller";
		Mass 50;
		+ROLLSPRITE
		+ROLLCENTER
		+FORCEPAIN
	}

	States
	{
		Spawn:
			RFTG BCDE 2 A_SetRoll(frandom(-15.5, 15.5));
			Loop;
	}
}

class HDRiftGrenadeAmmo : HDAmmo
{
	override bool IsUsed() { return true; }

	override void AttachToOwner(Actor user)
	{
		user.GiveInventory("HDRiftGrenades", 1);
		Super.AttachToOwner(user);
	}

	override void DetachFromOwner()
	{
		if(!(owner.player.ReadyWeapon is "HDRiftGrenades"))
		{
			owner.TakeInventory("HDRiftGrenades", 1);
		}
		Super.DetachFromOwner();
	}

	Default
	{
		Tag "Rift Grenade";
		HDPickup.Bulk 25;
		Inventory.MaxAmount 20;
		Scale 0.4;
		Inventory.Icon "RFTGA0";
		HDPickup.RefID "rtg";
		Inventory.PickupMessage "Picked up a rift grenade.";
		Inventory.PickupSound "weapons/pocket";
		+INVENTORY.KEEPDEPLETED
	}

	States
	{
		Spawn:
			RFTG A -1;
			Stop;
	}
}

class RiftGrenadeStack : Actor
{
	States
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				A_SpawnItemEx("HDRiftGrenadeAmmo", 8, 0, flags: SXF_NOCHECKPOSITION);
				A_SpawnItemEx("HDRiftGrenadeAmmo", -8, 0, flags: SXF_NOCHECKPOSITION);
				A_SpawnItemEx("HDRiftGrenadeAmmo", 0, 8, flags: SXF_NOCHECKPOSITION);
				A_SpawnItemEx("HDRiftGrenadeAmmo", 0, -8, flags: SXF_NOCHECKPOSITION);
			}
			Stop;
	}
}

// class HDRiftMarker : MapMarker
// {
// 	override void Tick()
// 	{
// 		if (!master)
// 		{
// 			Destroy();
// 			return;
// 		}

// 		Super.Tick();
// 	}

// 	Default
// 	{
// 		+INVISIBLE
// 		+NOINTERACTION
// 	}

// 	States
// 	{
// 		Spawn:
// 			TPRT Z -1;
// 			Stop;
// 	}
// }
