version "4.0"

class HDTeleportHandler : EventHandler
{
	Array<HDBeacon> Beacons;

	override void NetworkProcess(ConsoleEvent e)
	{
		let plr = HDPlayerPawn(players[e.Player].mo);
		if (!plr)
		{
			return;
		}

		bool Alive = plr.Health > 0;

		if (Alive && e.Name ~== "HDT_ListBeacons")
		{
			static const string Directions[] = { "West", "South-West", "South", "South-East", "East", "North-East", "North", "North-West" };
			int BeaconCount = 0;
			string BeaconList = "";
			for (int i = 0; i < Beacons.Size(); ++i)
			{
				if (Beacons[i])
				{
					vector3 BeaconPos = Beacons[i].pos;
					double a = (180 + plr.AngleTo(Beacons[i]) + 22.5) % 360;
					BeaconList = String.Format("%sBeacon %i at %i, %i, %i. Relative direction: %s.\n", BeaconList, i + 1, BeaconPos.x, BeaconPos.y, BeaconPos.z, Directions[int(a / 45)]);
					BeaconCount++;
				}
			}
			if (BeaconCount > 0)
			{
				string FinalString = String.Format("You have %i beacon%s active:\n%s", BeaconCount, (BeaconCount > 1 ? "s" : ""), BeaconList);
				plr.A_Log(FinalString, true);
			}
			else
			{
				plr.A_Log("You have no beacons active.", true);
			}
		}
	}

	int AddBeacon(HDBeacon beacon)
	{
		// [Ace] See if any of the previous beacons slots are empty. If not, push a new beacon. If they are, put them there.
		// All this does is it prevents indices from getting all shifted around when someone picks up a beacon.
		for (int i = 0; i < Beacons.Size(); ++i)
		{
			if (!Beacons[i])
			{
				Beacons[i] = beacon;
				return i;
			}
		}

		Beacons.Push(beacon);
		return Beacons.Size() - 1;
	}

	override void WorldThingSpawned(WorldEvent e)
	{
		let TheItem = HDBattery(e.Thing);
		if (TheItem)
		{
			TheItem.ItemsThatUseThis.Push("HDTeleporter");
		}
	}
}

class HDTeleporter : HDPickup
{
	override void BeginPlay()
	{
		BeaconIndex = -1;

		Super.BeginPlay();
	}

	override int GetSbarNum(int flags)
	{
		let HDHud = HDStatusBar(StatusBar);

		int Col = Font.CR_SAPPHIRE;
		HDBeacon SelBeacon = GetSelectedBeacon();
		if (SelBeacon)
		{
			HDBattery Battery = HDBattery(owner.FindInventory("HDBattery"));
			if (Battery)
			{
				int Cost = GetTeleportationCost(owner.Distance3D(SelBeacon));

				int BatteryIndex, BatteryCharge;
				[BatteryIndex, BatteryCharge] = GetLowestBattery(Battery, Cost);

				Col = BatteryCharge >= Cost ? Font.CR_GREEN : Font.CR_RED;
			}
			else
			{
				Col = Font.CR_RED;
			}
		}

		HDHud.SavedColour = col;
		return BeaconIndex + 1;
	}

	private clearscope HDBeacon GetSelectedBeacon()
	{
		let Handler = HDTeleportHandler(EventHandler.Find("HDTeleportHandler"));
		if (BeaconIndex > -1 && BeaconIndex < Handler.Beacons.Size())
		{
			return Handler.Beacons[BeaconIndex];
		}
		return null;
	}

	private clearscope int, int GetLowestBattery(HDBattery stack, int minCharge)
	{
		if (stack)
		{
			int LowestIndex = stack.Mags.Size() - 1;
			int LowestCharge = stack.MaxPerUnit;
			for (int i = LowestIndex; i >= 0; --i)
			{
				if (stack.Mags[i] >= minCharge && stack.Mags[i] <= LowestCharge)
				{
					LowestIndex = i;
					LowestCharge = stack.Mags[i];
				}
			}

			// [Ace] Do a final check to see if the battery fulfills the conditions.
			// If there is only one battery and the charge is < minCharge, the loop above won't do much.
			if (stack.Mags[LowestIndex] >= minCharge)
			{
				return LowestIndex, stack.Mags[LowestIndex];
			}
		}

		return -1, 0;
	}

	private clearscope int GetTeleportationCost(double dist) const
	{
		return 1 + int(dist / (42 * 5));
	}

	private int BeaconIndex; // [Ace] Zero-based internally, but not on the HUD.

	Default
	{
		+HDPICKUP.CHEATNOGIVE
		+HDPICKUP.NOTINPOCKETS
		+INVENTORY.INVBAR
		HDPickup.Bulk 50;
		HDPickup.RefID "ptp";
		Inventory.MaxAmount 5;
		Inventory.Icon "TPRTZ0";
		Inventory.PickupMessage "Picked up a portable teleporter.";
		Tag "Portable Teleporter";
	}

	States
	{
		Spawn:
			TPRT A -1;
			Stop;
		Use:
			TNT1 A 0
			{
				let Handler = HDTeleportHandler(EventHandler.Find("HDTeleportHandler"));
				if (!Handler)
				{
					return false;
				}

				if (player.cmd.buttons & BT_USE)
				{
					if (player.cmd.buttons & BT_ZOOM && invoker.BeaconIndex > -1)
					{
						invoker.BeaconIndex--;
					}
					else
					{
						invoker.BeaconIndex++;
					}
					return false;
				}
				else if (player.cmd.buttons & BT_ZOOM)
				{
					bool success; Actor a;

					double sinp = sin(pitch);
					double cosp = cos(pitch);

					double XVel = 3 + ((player.cmd.buttons & BT_SPEED ? 15 : 2) * (CheckInventory("PowerStrength", 0) ? 3 : 1)) * cosp;
					double ZVel = (10 * -sinp) * (CheckInventory("PowerStrength", 0) ? 2 : 1);

					[success, a] = A_SpawnItemEx("HDBeacon", 0, 0, height / 2 + 4, XVel, 0, ZVel, flags: SXF_SETMASTER | SXF_TRANSFERTRANSLATION);
					a.SetShade(player.GetColor());
					a.vel += vel;

					int PlacedIndex = Handler.AddBeacon(HDBeacon(a)) + 1;
					A_Log(String.Format("%s placed a beacon near (%i, %i, %i) with index %i.", player.GetUserName(), pos.x, pos.y, pos.z, PlacedIndex));

					invoker.Amount--;
					return false;
				}

				HDBeacon SelBeacon = invoker.GetSelectedBeacon();
				if (!SelBeacon)
				{
					A_Log("Invalid index. Use 'listbeacons' in console for a list of active beacons.", true);
					return false;
				}

				let Battery = HDBattery(FindInventory("HDBattery"));
				if (!Battery)
				{
					A_Log("No batteries found.", true);
					return false;
				}

				int Cost = invoker.GetTeleportationCost(Distance3D(SelBeacon));
				int BatteryIndex, BatteryCharge;
				[BatteryIndex, BatteryCharge] = invoker.GetLowestBattery(Battery, Cost);

				if (Cost > BatteryCharge)
				{
					A_Log("Insufficient charge.", true);
					return false;
				}

				if (!SelBeacon.Armed)
				{
					A_Log("Beacon is not armed.", true);
					return false;
				}

				if (Warp(SelBeacon, flags: WARPF_USECALLERANGLE))
				{
					for (int i = 0; i < 360; ++i)
					{
						if (!random(0, 1))
						{
							A_SpawnParticle(player.GetColor(), SPF_RELATIVE, random(35, 70), random(2, 4), i, random(8, 48), 0, frandom(0, height), 0, 0, frandom(0.5, 3), 0, 0, frandom(-0.05, 0));
						}
						A_SpawnParticle(player.GetColor(), SPF_RELATIVE, 15, 16, i, 0, 0, 0, 20, 0, 0, -0.8, sizestep: 0.3);
					}
					// [Ace] Take whatever you're holding with you.
					let Fists = HDFist(player.ReadyWeapon);
					if (Fists && Fists.Grabbed)
					{
						Fists.Grabbed.Warp(SelBeacon, radius + 12, angle: angle, flags: WARPF_ABSOLUTEANGLE);
					}

					A_PlaySound("HDTeleporter/Teleport", 20);
					Battery.Mags[BatteryIndex] -= Cost;
				}
				else
				{
					A_Log("Destination is blocked.", true);
				}

				return false;
			}
			Stop;
	}
}

class HDBeacon : HDUPK
{
	private void EmitParticles(double height)
	{
		for (double i = 0; i < height; i += height / 32.0)
		{
			A_SpawnParticle(fillcolor, SPF_FULLBRIGHT, 1,  8 + i ** 1.18, 0, 0, 0, 3 + i * 3, startalphaf: 0.50 * (1.0 - i / height));
		}
	}

	private PointLight DynLight;
	private double StartHeight;
	bool Armed;

	Default
	{
		Radius 12;
		HDUPK.PickupType "HDTeleporter";
		HDUPK.PickupMessage "Picked up a portable teleporter.";
		HDUPK.MaxUnitAmount 5;
	}

	States
	{
		Spawn:
			TPRT A 1
			{
				if (vel.length() < 0.1)
				{
					A_SpawnItemEx("HDBeaconMarker", flags: SXF_SETMASTER | SXF_TRANSFERTRANSLATION);
					SetStateLabel("WindUp");
				}
			}
			Loop;
		WindUp:
			TPRT BCDEFG 4;
			TPRT CDEFG 4;
			TPRT CDEFG 3;
			TPRT CDEFG 2;
			TPRT C 0
			{
				DynLight = PointLight(Spawn("HDBeaconLight"));
				DynLight.master = self;
				DynLight.Args[0] = fillcolor.r;
				DynLight.Args[1] = fillcolor.g;
				DynLight.Args[2] = fillcolor.b;
				Armed = true;
			}
		Speen:
			TPRT CCDDEEFFGG 1
			{
				if (StartHeight < 32)
				{
					StartHeight += 4;
					if (DynLight)
					{
						DynLight.Args[3] = int(StartHeight * 2);
					}
				}
				A_StartSound("HDTeleporter/Idle", 7, CHANF_NOSTOP | CHANF_LOOP, 0.20);
				EmitParticles(StartHeight);
			}
			Loop;
	}
}

class HDBeaconMarker : MapMarker
{
	override void Tick()
	{
		if (!master)
		{
			Destroy();
			return;
		}

		Super.Tick();
	}

	Default
	{
		+INVISIBLE
		+NOINTERACTION
	}

	States
	{
		Spawn:
			TPRT Z -1;
			Stop;
	}
}

class HDBeaconLight : PointLight
{
	override void Tick()
	{
		if (!master)
		{
			Destroy();
			return;
		}

		Warp(master, flags: WARPF_NOCHECKPOSITION);

		Super.Tick();
	}
}